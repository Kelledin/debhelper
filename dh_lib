# Library functions for debhelper programs.
#
# Joey Hess, GPL copyright 1997, 1998.

# Run a command, and display the command to stdout if verbose mode is on.
# All commands that modifiy files in $TMP should be ran via this 
# function.
# Note that this cannot handle complex commands, especially anything
# involving redirection. Use complex_doit instead.
doit() {
	verbose_echo "$@"
	if [ ! "$DH_NO_ACT" ]; then
		eval '$@'
	fi
}


# This is an identical command to doit, except the parameter passed to it
# are evaled with double quotes. This version can handle compound commands.
complex_doit() {
	verbose_echo "$@"
	if [ ! "$DH_NO_ACT" ]; then
		eval "$@"
	fi
}

# Echo something if the verbose flag is on.
verbose_echo() {
	if [ "$DH_VERBOSE" ]; then
		echo "	$@"
	fi
}

# Echo an error message and exit.
error() {
	echo `basename $0`": $1" >&2
	exit 1
}

# Output a warning.
warning() {
	echo `basename $0`": $1" >&2
}

# Pass it a name of a binary package, it returns the name of the tmp dir to
# use, for that package.
# This is for back-compatability with the debian/tmp tradition.
tmpdir() {
	if [ "$DH_TMPDIR" ]; then
		echo "$DH_TMPDIR"
	elif [ "$1" = "$MAINPACKAGE" ]; then
		echo debian/tmp
	else
		echo "debian/$PACKAGE"
	fi
}

# Pass this the name of a binary package, and the name of the file wanted
# for the package, and it will return the actual filename to use. For
# example if the package is foo, and the file is somefile, it will look for 
# debian/somefile, and if found return that, otherwise, if the package is
# the main package, it will look for debian/foo, and if found, return that. 
# Failing that, it will return nothing.
pkgfile() {
	if [ -e "debian/$1.$2" ]; then
		echo "debian/$1.$2"
	elif [ "$1" = "$MAINPACKAGE" -a -e "debian/$2" ]; then
		echo "debian/$2"
	fi
}

# Pass it a name of a binary package, it returns the name to prefix to files
# in debian for this package.
pkgext() {
	if [ "$1" != "$MAINPACKAGE" ]; then
	echo "$PACKAGE."
	fi
}

# Returns 1 if the package is a native debian package, null otherwise.
# As a side effect, sets $VERSION to the version of this package.
# Caches return code so it only needs to run dpkg-parsechangelog once.
isnative() {
	if [ -z "$DH_ISNATIVE" ]; then
		# Get the package version.
		# Note that the 2>/dev/null is because a bug in dpkg-parsechangelog makes it
		# output a bogus error message to stderr.
		# If it actually has a real error, then the expr will fail, and this whole
		# script will come crashing to a halt, which is good enough to inform
		# the user something's wrong. :-)
		VERSION=`expr "\`dpkg-parsechangelog 2>/dev/null\`" : \
			'.*Version: \(.*\).*Distribution:'`
		# Is this a native Debian package?
		if expr "$VERSION" : '.*-' >/dev/null; then
			DH_ISNATIVE=1
		else
			DH_ISNATIVE=0
		fi
	fi

	return "$DH_ISNATIVE"
}

# Automatically add a shell script snippet to a debian script.
# Only works if the script has #DEBHELPER# in it.
#
# Parameters:
# 1: script to add to
# 2: filename of snippet
# 3: sed commands to run on the snippet. Ie, s/#PACKAGE#/$PACKAGE/
autoscript() {
	autoscript_script=$1
	autoscript_filename=$2
	autoscript_sed=$3
	autoscript_debscript=debian/`pkgext $PACKAGE`$autoscript_script.debhelper

	if [ -e "$DH_AUTOSCRIPTDIR/$autoscript_filename" ]; then
		autoscript_filename="$DH_AUTOSCRIPTDIR/$autoscript_filename"
	else
		if [ -e "/usr/lib/debhelper/autoscripts/$autoscript_filename" ]; then
			autoscript_filename="/usr/lib/debhelper/autoscripts/$autoscript_filename"
		else
			error "/usr/lib/debhelper/autoscripts/$autoscript_filename does not exist"
		fi
	fi

	complex_doit "echo \"# Automatically added by `basename $0`\" >> $autoscript_debscript"
	complex_doit "sed \"$autoscript_sed\" $autoscript_filename >> $autoscript_debscript"
	complex_doit "echo '# End automatically added section' >> $autoscript_debscript"
}

# Sets 2 global variables, INDEP_PACKAGES is all the arch-independant
# packages, ARCH_PACKAGES is the arch-dependant packages.
get_arch_indep_packages() {
	INDEP_PACKAGES=""
	ARCH_PACKAGES=""
	
	# First, get the list of all binary packages.
        # Notice we want the list in reverse order, thus the tac.
	PACKAGES=`grep ^Package: debian/control | cut -d " " -f 2 | tac | tr "\n" " "`
	# Remove trailing space.
	PACKAGES=`expr "$PACKAGES" : '\(.*\) '`
	# Loop on the list of architectures.
	for ARCH in `grep ^Architecture: debian/control | cut -d " " -f 2` ; do
		# Pull the last package off the list.
		THISPKG=`expr "$PACKAGES" : '.* \(.*\)'` || true
		if [ ! "$THISPKG" ]; then
			THISPKG=$PACKAGES
		fi
		PACKAGES=`expr "$PACKAGES" : '\(.*\) .*'` || true
	
		if [ ! "$THISPKG" ]; then
			error "debian/control invalid - too many Architecture lines or too few Package lines"
		fi

		if [ "$ARCH" = "all" ]; then
			INDEP_PACKAGES="$INDEP_PACKAGES $THISPKG"
		else
			ARCH_PACKAGES="$ARCH_PACKAGES $THISPKG"
		fi
	done

	if [ "$PACKAGES" ]; then
		error "debian/control invalid - too many Architecure lines or too few Package lines"
	fi
}

# Argument processing and global variable initialization is below.

# Check to see if an argument on the command line starts with a dash.
# if so, we need to pass this off to the resource intensive perl.
for arg; do
	if expr "$arg" : '-' >/dev/null ; then
		parseopt=1
		break
	fi
done
if [ "$parseopt" ]; then
	parseopt=""
	# Parse command line. I wrote a perl program to do this becuase
	# getopt(1) is so broken. Note: the quotes around $@ are very
	# important!
	eval `dh_getopt.pl "$@"`
	if [ "$DH_PARSE_ERROR" ]; then
		error "$DH_PARSE_ERROR"
	fi
fi

# Get the name of the main binary package (first one listed in
# debian/control).
MAINPACKAGE=`grep ^Package: debian/control | cut -d " " -f 2 | head -1`

# Check if packages to build have been specified, if not, fall back to 
# the default, doing them all.
if [ ! "$DH_DOPACKAGES" ]; then
	if [ "$DH_DOINDEP" -o "$DH_DOARCH" ]; then
		error "I have no package to build."
	fi
	DH_DOPACKAGES=`grep ^Package: debian/control | cut -d " " -f 2 | tr "\n" " "`
fi

# Check to see if -P was specified. If so, we can only act on a single
# package.
if [ "$DH_TMPDIR" ] && echo "$DH_DOPACKAGES" | egrep -q '.+ .+' ; then
	error "-P was specified, but multiple packages would be acted on."
fi

# Figure out which package is the first one we were instructed to build.
# This package gets special treatement, files and directories specified on
# the command line may effect it.
for PACKAGE in $DH_DOPACKAGES ; do
	DH_FIRSTPACKAGE="$PACKAGE"
	break
done
