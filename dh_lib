# Library functions for debhelper programs.

# Run a command, and display the command to stdout if verbose mode is on.
# All commands that modifiy files in $TMP should be ran via this 
# function.
# Note that this cannot handle complex commands, especially anything
# involving redirection. Use complex_doit instead.
doit() {
	verbose_echo "$@"
	eval '$@'
}


# This is an identical command to doit, except the parameter passed to it
# are evaled with double quotes. This version can handle compound commands.
complex_doit() {
	verbose_echo "$@"
	eval "$@"
}

# Echo something if the verbose flag is on.
verbose_echo() {
	if [ "$DH_VERBOSE" ]; then
		echo "	$@"
	fi
}

# Echo an error message and exit.
error() {
	echo `basename $0`": $1" >&2
	exit 1
}

# Pass it a name of a binary package, it returns the name of the tmp dir to
# use, for that package.
# This is for back-compatability with the debian/tmp tradition.
tmpdir() {
	if [ "$DH_TMPDIR" ]; then
		echo "$DH_TMPDIR"
	elif [ "$1" = "$MAINPACKAGE" ]; then
		echo debian/tmp
	else
		echo "debian/$PACKAGE"
	fi
}

# Pass it a name of a binary package, it returns the name to prefix to files
# in debian for this package.
pkgext() {
	if [ "$1" != "$MAINPACKAGE" ]; then
		echo "$PACKAGE."
	fi
}

# Returns 1 if the package is a native debian package, null otherwise.
# As a side effect, sets $VERSION to the version of this package.
# Caches return code so it only needs to run dpkg-parsechangelog once.
isnative() {
	if [ -z "$DH_ISNATIVE" ]; then
		# Get the package version.
		# Note that the 2>/dev/null is because a bug in dpkg-parsechangelog makes it
		# output a bogus error message to stderr.
		# If it actually has a real error, then the expr will fail, and this whole
		# script will come crashing to a halt, which is good enough to inform
		# the user something's wrong. :-)
		VERSION=`expr "\`dpkg-parsechangelog 2>/dev/null\`" : \
			'.*Version: \(.*\).*Distribution:'`
		# Is this a native Debian package?
		if expr "$VERSION" : '.*-' >/dev/null; then
			DH_ISNATIVE=1
		else
			DH_ISNATIVE=0
		fi
	fi

	return "$DH_ISNATIVE"
}

# Automatically add a shell script snippet to a debian script.
# Only works if the script has #DEBHELPER# in it.
#
# Parameters:
# 1: script to add to
# 2: filename of snippet
# 3: sed commands to run on the snippet. Ie, s/#PACKAGE#/$PACKAGE/
autoscript() {
	autoscript_script=$1
	autoscript_filename=$2
	autoscript_sed=$3
	autoscript_debscript=debian/`pkgext $PACKAGE`$autoscript_script.debhelper

	if [ -e "$DH_AUTOSCRIPTDIR/$autoscript_filename" ]; then
		autoscript_filename="$DH_AUTOSCRIPTDIR/$autoscript_filename"
	else
		if [ -e "/usr/lib/debhelper/autoscripts/$autoscript_filename" ]; then
			autoscript_filename="/usr/lib/debhelper/autoscripts/$autoscript_filename"
		else
			error "/usr/lib/debhelper/autoscripts/$autoscript_filename does not exist"
		fi
	fi

	complex_doit "echo \"# Automatically added by `basename $0` on `822-date`\" >> $autoscript_debscript"
	complex_doit "sed \"$autoscript_sed\" $autoscript_filename >> $autoscript_debscript"
	complex_doit "echo '# End automatically added section' >> $autoscript_debscript"
}

# Sets 2 global variables, INDEP_PACKAGES is all the arch-independant
# packages, ARCH_PACKAGES is the arch-dependant packages.
get_arch_indep_packages() {
	INDEP_PACKAGES=""
	ARCH_PACKAGES=""
	
	# First, get the list of all binary packages.
        # Notice we want the list in reverse order, thus the tac.
	PACKAGES=`grep ^Package: debian/control | cut -d " " -f 2 | tac | tr "\n" " "`
	# Remove trailing space.
	PACKAGES=`expr "$PACKAGES" : '\(.*\) '`
	# Loop on the list of architectures.
	for ARCH in `grep ^Architecture: debian/control | cut -d " " -f 2` ; do
		# Pull the last package off the list.
		THISPKG=`expr "$PACKAGES" : '.* \(.*\)'` || true
		if [ ! "$THISPKG" ]; then
			THISPKG=$PACKAGES
		fi
		PACKAGES=`expr "$PACKAGES" : '\(.*\) .*'` || true
	
		if [ ! "$THISPKG" ]; then
			error "debian/control invalid - too many Architecture lines or too few Package lines"
		fi

		if [ "$ARCH" = "all" ]; then
			INDEP_PACKAGES="$INDEP_PACKAGES $THISPKG"
		else
			ARCH_PACKAGES="$ARCH_PACKAGES $THISPKG"
		fi
	done

	if [ "$PACKAGES" ]; then
		error "debian/control invalid - too many Architecure lines or too few Package lines"
	fi
}

# Argument processing and global variable initialization is below.

# Parse command line.
set -- `getopt xvidrnakVAp:P:u:m: $*`

for i; do
	case "$i"
	in
		-v)
			DH_VERBOSE=1
			shift
			;;
		-i)
			get_arch_indep_packages
			DH_DOPACKAGES="$DH_DOPACKAGES $INDEP_PACKAGES"
			DH_DOINDEP=1
			shift
			;;
		-a)
			get_arch_indep_packages
			DH_DOPACKAGES="$DH_DOPACKAGES $ARCH_PACKAGES"
			DH_DOARCH=1
			shift
			;;
		-p)
			DH_DOPACKAGES="$DH_DOPACKAGES $2"
			shift
			shift
			;;
		-n)
			DH_NOSCRIPTS=1
			shift
			;;
		-x)	
			DH_EXCLUDE=1
			shift
			;;
		-d)
			DH_D_FLAG=1
			shift
			;;
		-r)
			DH_R_FLAG=1
			shift
			;;
		-k)
			DH_K_FLAG=1
			shift
			;;
		-P)
			DH_TMPDIR="$2"
			shift
			shift
			;;
		-u)
			DH_U_PARAMS="$2"
			shift
			shift
			;;
		-m)
			DH_M_PARAMS="$2"
			shift
			shift
			;;
		-V)
			DH_V_FLAG=1
			shift
			;;
		-A)
			DH_PARAMS_ALL=1
			shift
			;;
		--)
			shift
			break
			;;
	esac
done

# Get the name of the main binary package (first one listed in
# debian/control).
MAINPACKAGE=`grep ^Package: debian/control | cut -d " " -f 2 | head -1`

# Remove leading spaces from DH_DOPACKAGES.
if expr "$DH_DOPACKAGES" : ' *.*' >/dev/null ; then
	DH_DOPACKAGES_NEW=`expr "$DH_DOPACKAGES" : ' *\(.*\)'`
fi

# Check if packages to build have been specified, if not, fall back to 
# the default, doing them all.
if [ ! "$DH_DOPACKAGES" ]; then
	if [ "$DH_DOINDEP" -o "$DH_DOARCH" ]; then
		error "I have no package to build."
	fi
	DH_DOPACKAGES=`grep ^Package: debian/control | cut -d " " -f 2 | tr "\n" " "`
fi

# Check to see if -P was specified. If so, we can only act on a single
# package.
if [ "$DH_TMPDIR" ] && echo "$DH_DOPACKAGES" | egrep -q '.+ .+' ; then
	error "-P was specified, but multiple packages would be acted on."
fi

# Figure out which package is the first one we were instructed to build.
# This package gets special treatement, files and directories specified on
# the command line may effect it.
for PACKAGE in $DH_DOPACKAGES ; do
	DH_FIRSTPACKAGE="$PACKAGE"
	break
done

# Check to see if: DH_FIRSTPACKAGE is not the MAINPACKAGE, and
# some command line arguemnts are passed. Display a warning, becuase
# debhelper's behaviour has changed in this case.
if [ "$DH_FIRSTPACKAGE" != "$MAINPACKAGE" -a "$*" ]; then
	echo `basename $0`": Warning: my behavior has changed, and command line" >&2
	echo `basename $0`": arguments \"$*\" will apply to package \"$DH_FIRSTPACKAGE\"" >&2
fi
