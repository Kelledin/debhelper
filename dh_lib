# Library functions for debhelper programs.

# Run a command, and display the command to stdout if verbose mode is on.
# All commands that modifiy files in $TMP should be ran via this 
# function.
doit() {
	verbose_echo "$@"
	eval "$@"
}

# Echo something if the verbose flag is on.
verbose_echo() {
	if [ "$DH_VERBOSE" ]; then
		echo "	$@"
	fi
}

# Echo an error message and exit.
error() {
	echo `basename $0`": $1" >&2
	exit 1
}

# Pass it a name of a binary package, it returns the name of the tmp dir to
# use, for that package.
# This is for back-compatability with the debian/tmp tradition.
tmpdir() {
	if [ "$DH_TMPDIR" ]; then
		echo "$DH_TMPDIR"
	elif [ "$1" = "$MAINPACKAGE" ]; then
		echo debian/tmp
	else
		echo "debian/$PACKAGE"
	fi
}

# Pass it a name of a binary package, it returns the name to prefix to files
# in debian for this package.
pkgext() {
	if [ "$1" != "$MAINPACKAGE" ]; then
		echo "$PACKAGE."
	fi
}

# Automatically add a shell script snippet to a debian script.
# Only works if the script has #DEBHELPER# in it.
#
# Parameters:
# 1: script to add to
# 2: filename of snippet
# 3: sed commands to run on the snippet. Ie, s/#PACKAGE#/$PACKAGE/
autoscript() {
	autoscript_script=$1
	autoscript_filename=$2
	autoscript_sed=$3
	autoscript_debscript=debian/`pkgext $PACKAGE`$autoscript_script.debhelper

	if [ -e "$DH_AUTOSCRIPTDIR/$autoscript_filename" ]; then
		autoscript_filename="$DH_AUTOSCRIPTDIR/$autoscript_filename"
	else
		if [ -e "/usr/lib/debhelper/autoscripts/$autoscript_filename" ]; then
			autoscript_filename="/usr/lib/debhelper/autoscripts/$autoscript_filename"
		else
			error "/usr/lib/debhelper/autoscripts/$autoscript_filename does not exist"
		fi
	fi

	# Running doit doesn't cut it here.
	doit "echo \"# Automatically added by `basename $0` on `822-date`\" >> $autoscript_debscript"
	doit "sed \"$autoscript_sed\" $autoscript_filename >> $autoscript_debscript"
	doit "echo '# End automatically added section' >> $autoscript_debscript"
}

# Argument processing and global variable initialization is below.

# Parse command line.
set -- `getopt xvianp:P: $*`

for i; do
	case "$i"
	in
		-v)
			DH_VERBOSE=1
			shift
			;;
		-i)
			DH_DOINDEP=1
			shift
			;;
		-a)
			DH_DOARCH=1
			shift
			;;
		-p)
			DH_DOPACKAGES="$DH_DOPACKAGES $2"
			shift
			shift
			;;
		-n)
			DH_NOSCRIPTS=1
			shift
			;;
		-x)	
			DH_EXCLUDE=1
			shift
			;;
		-P)
			DH_TMPDIR="$2"
			shift
			shift
			;;
		--)
			shift
			break
			;;
	esac
done

# Get the package version from the changelog.
LINE=`head -1 debian/changelog`
VERSION=`expr "$LINE" : '.* (\(.*\))'`

# Get the name of the main binary package.
MAINPACKAGE=`grep ^Package: debian/control | cut -d " " -f 2 | head -1`

# Is this a native Debian package?
if ! expr "$VERSION" : '.*-' >/dev/null; then
       	NATIVE=1
fi

if [ "$DH_DOINDEP" -o "$DH_DOARCH" ]; then
	# Figure out all the binary packages to be produced, by looking at the
	# control file. Break it into 2 lists, INDEP_PACKAGES and ARCH_PACKAGES.
	#
	# First, get the list of all binary packages.
	PACKAGES=`grep ^Package: debian/control | cut -d " " -f 2 | tr "\n" " "`
	# Remove trailing space.
	PACKAGES=`expr "$PACKAGES" : '\(.*\) '`
	# Loop on the list of architectures. Note that we tac the result to reverse
	# it, becuase we are going through the list of packages in reverse.
	for ARCH in `grep ^Architecture: debian/control | tac | cut -d " " -f 2` ; do
		THISPKG=`expr "$PACKAGES" : '.* \(.*\)'` || true
		if [ ! "$THISPKG" ]; then
			THISPKG=$PACKAGES
		fi
	        PACKAGES=`expr "$PACKAGES" : '\(.*\) .*'` || true
		if [ ! "$THISPKG" ]; then
			error "debian/control invalid - too many Architecture lines or too few Package lines"
		fi
		if [ "$ARCH" = "all" ]; then
			INDEP_PACKAGES="$INDEP_PACKAGES $THISPKG"
		else
			ARCH_PACKAGES="$ARCH_PACKAGES $THISPKG"
		fi
	done

	if [ "$PACKAGES" ]; then
		error "debian/control invalid - too many Architecure lines or too few Package lines"
	fi
	if [ "$DH_DOINDEP" ]; then
		DH_DOPACKAGES="$DH_DOPACKAGES $INDEP_PACKAGES"
	fi
	if [ "$DH_DOARCH" ]; then
		DH_DOPACKAGES="$DH_DOPACKAGES $ARCH_PACKAGES"
	fi
fi

# Check if packages to build have been specified, if not, fall back to 
# the default, doing them all. Note that DH_DOPACKAGES may have a leading
# space and be empty otherwise.
if [ ! "$DH_DOPACKAGES" -o "$DH_DOPACKAGES" = " " ]; then
	if [ "$DH_DOINDEP" -o "$DH_DOARCH" ]; then
		error "I have no package to build."
	fi
	DH_DOPACKAGES=`grep ^Package: debian/control | cut -d " " -f 2`
fi

# Check to see if -P was specified. If so, we can only act on a single
# package.
if [ "$DH_TMPDIR" ] && echo "$DH_DOPACKAGES" | egrep -q '.+ .+' ; then
	error "-P was specified, but multiple packages would be acted on."
fi
