#!/usr/bin/perl

=head1 NAME

dh_missing - check for missing files

=cut

use strict;
use warnings;
use File::Find;
use Debian::Debhelper::Dh_Lib;

our $VERSION = DH_BUILTIN_VERSION;

=head1 SYNOPSIS

B<dh_missing> [B<-X>I<item>] [B<--sourcedir=>I<dir>] [S<I<debhelper options>>]

=head1 DESCRIPTION

B<dh_missing> compares the list of installed files with the files in
the source directory. If any of the files (and symlinks) in the source
directory were not installed to somewhere, it will warn on stderr
about that (B<--list-missing>) or fail (B<--fail-missing>).  Please
note that without either of these options, B<dh_missing> will silently
do nothing.

This may be useful if you have a large package and want to make sure that
you don't miss installing newly added files in new upstream releases.

Remember to test different kinds of builds (dpkg-buildpackage -A/-B/...) as
you may experience varying results when only a subset of the packages are
built.

=head1 FILES

=over 4

=item debian/not-installed

List the files that are deliberately not installed in I<any> binary
package.  Paths listed in this file are ignored by B<dh_missing>.
However, it is B<not> a method to exclude files from being installed
by B<dh_install>. Please use the B<--exclude> B<dh_install> option for
that.

Please keep in mind that B<dh_missing> will B<not> expand wildcards in
this file.

=back

=head1 OPTIONS

=over 4

=item B<--list-missing>

Warn on stderr about source files not installed to somewhere.

Note that files that are excluded from being moved via the B<-X> option are not
warned about.

=item B<--fail-missing>

This option is like B<--list-missing>, except if a file was missed, it will
not only list the missing files, but also fail with a nonzero exit code.

=back

=cut

init(options => {
	"list-missing" => \$dh{LIST_MISSING},
	"fail-missing" => \$dh{FAIL_MISSING},
	"sourcedir=s" => \$dh{SOURCEDIR},
});

my (@installed, %helpers, @source_dirs);


if (!$dh{LIST_MISSING} && !$dh{FAIL_MISSING}) {
	exit 0;
}

if (not defined($dh{SOURCEDIR}) and scalar(getpackages()) == 1) {
	# Special-case where every thing is installed directly into the
	# package directory.
	exit(0);
} elsif (defined($dh{SOURCEDIR})) {
	my $srcdir = $dh{SOURCEDIR};
	# . as srcdir makes no sense, so this is a special case.
	$srcdir = 'debian/tmp' if $srcdir eq '.';
	if (not -d $srcdir) {
		if (compat(10)) {
			# Prevent "dh $@ --list-missing --destdir=..." from failing in compat 10.
			warning("Cannot check if installation is missing files: $srcdir does not exist");
			exit(0);
		} else {
			error("Cannot check if installation is missing files: $srcdir does not exist");
		}
	}
	push(@source_dirs, $srcdir);
} else {
	exit 0 if not -d 'debian/tmp';
	push(@source_dirs, 'debian/tmp');
}


for my $file (<debian/.debhelper/generated/*/installed-by-*>) {
	my ($target_pkg, $helper) = ('unknown', 'unknown');
	my $had_files = 0;
	my %seen;
	if ($file =~ m@.*/([^/]+)/installed-by-(.*)@) {
		($target_pkg, $helper) = ($1, $2);
	}

	open(my $fh, '<', $file) or die "could not open $file: $!";
	while (my $line = <$fh>) {
		chomp($line);
		next if $line =~ m/^\s*$/;
		next if $seen{$line}++; # Ignore duplicates
		$had_files++;
		push(@installed, $line);
	}
	$helpers{$helper}{$target_pkg} = $had_files;
	close($fh);
}



my %missing_by_sourcedir;
if ( -f 'debian/not-installed') {
	my @not_installed = filearray('debian/not-installed');
	foreach (@not_installed) {
		s:^\s*:debian/tmp/: if not m:^\s*debian/:;
	}
	# Pretend that these are also installed.
	push(@installed, @not_installed);
}
my $installed=join("|", map {
	# Kill any extra slashes, for robustness.
	y:/:/:s;
	s:/+$::;
	s:^(\./)*::;
	"\Q$_\E\/.*|\Q$_\E";
} @installed);
$installed=qr{^($installed)$};
for my $srcdir (@source_dirs) {
	find(sub {
		-f || -l || return;
		$_="$File::Find::dir/$_";
		if (! /$installed/ && ! excludefile($_)) {
			my $file=$_;
			$file=~s{^\Q$srcdir\E/}{};
			push(@{$missing_by_sourcedir{$srcdir}}, $file);
		}
	}, $srcdir);
}
if (%missing_by_sourcedir) {
	for my $sdir (sort(keys(%missing_by_sourcedir))) {
		for my $file (@{$missing_by_sourcedir{$sdir}}) {
			warning("$file exists in $sdir but is not installed to anywhere");
		}
	}
	nonquiet_print("The following debhelper tools have reported what they installed (with files per package)");
	for my $helper (sort(keys(%helpers))) {
		my $pkg_info = $helpers{$helper};
		my @results;
		for my $pkg (sort(keys(%{$pkg_info}))) {
			my $no = $pkg_info->{$pkg};
			push(@results, "${pkg} (${no})")
		}
		nonquiet_print(" * ${helper}: " . join(', ', @results));
	}
	nonquiet_print("If the missing files are installed by another tool, please file a bug against it.");
	nonquiet_print('When filing the report, if the tool is not part of debhelper itself, please reference the');
	nonquiet_print('"Logging helpers and dh_missing" section from the "PROGRAMMING" guide for debhelper (10.6.3+).');
	nonquiet_print('  (in the debhelper package: /usr/share/doc/debhelper/PROGRAMMING.gz)');
	nonquiet_print("Be sure to test with dpkg-buildpackage -A/-B as the results may vary when only a subset is built");
	nonquiet_print("For a short-term work-around: Add the files to debian/not-installed");
	if ($dh{FAIL_MISSING}) {
		error("missing files, aborting");
	}
}

=head1 SEE ALSO

L<debhelper(7)>

This program is a part of debhelper.

=head1 AUTHOR

Michael Stapelberg <stapelberg@debian.org>

=cut
